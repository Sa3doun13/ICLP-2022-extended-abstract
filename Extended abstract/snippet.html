<!--This an example of an HTML snippet. It features plain text,
    paragraph breaks, a list, pictures, LaTeX formulae,
    a table, a section header, and references.
    A snippet is not an HTML page; it will be part of an HTML page.
    Therefore, it should not have commands like <html>, <head>, <body> etc.
    It should certainly not have any commands that mess with point size, margins, etc.
    To see how this shows up in a browser, rename the file into "snippet.html". -->

<!--This is a comment. Comments are not displayed in the browser.-->

<style type="text/css"> .tg {width:1200px; border:none;border-collapse:collapse;border-spacing:0;} .tg td{border-style:solid;border-width:0px;font-family:Arial, sans-serif;font-size:14px;overflow:hidden; padding:10px 5px;word-break:normal;} .tg th{border-style:solid;border-width:0px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal; overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0lax{text-align:left;vertical-align:top} .tg .tg-7zrl{text-align:left;vertical-align:bottom} </style>


<center>
  <H1>Solving a Multi-resource Partial-ordering Flexible Variant of the Job-shop Scheduling Problem with Hybrid ASP (Extended Abstract)</H1>
</center>
<center>
  <table style="width:50%">
  <tr>
    <th>Giulia Francescutto</th>
    <th>Konstantin Schekotihin</th>
    <th>Mohammed M. S. El-Kholany</th>
  </tr>
  <tr>
    <td> <center> Siemens AG Österreich, Vienna, Austria </center> </td>
    <td> <center> University of Klagenfurt, Klagenfurt, Austria </center> </td>
    <td> <center> University of Klagenfurt, Klagenfurt, Austria</td> </center>
  </tr>
  <tr>
    <td> <center> giulia.francescutto@siemens.com </center></td>
    <td> <center> konstantin.schekotihin@aau.at </center></td>
    <td> <center> mohammed.el-kholany@aau.at </center></td>
  </tr>
</table>
</center>

<center>
  <H3> Abstract</H3>
<P style="margin: 20px; width: 60%">
  In many industries, scheduling is a key component to efficient management of resources and, thus, ensuring competitiveness and success of companies by reducing the consumption of time and money. In this work, we propose a <em> Multi-resource Partial-ordering Flexible Job-shop Scheduling </em> formulation to capture scheduling scenarios where partially-ordered sequences of operations must be scheduled on multiple required resources, such as tools and specialists.
  The resources are flexible and can process one or more kind of operations based on their characteristics. We have built a model using Answer Set Programming in which the execution time of operations is determined using Difference Logic. Furthermore, we introduced two multi-shot strategies that identify the time bounds and find a schedule while minimizing the total tardiness. Experiments on real-world instances from an Infineon Fault Analysis lab show that the devised model yields optimized schedules for 87 out of 91 instances.  
</P>
</center>

<H3>1. Introduction</H3>

<P>
Job-shop Scheduling (JSS) ([<A HREF=#13.7>7</A>]) is one of the most well-known scheduling problems in which a set of machines are used to execute given jobs, represented as sequences of operations, and the goal is to complete the jobs as soon as possible. Extensions like flexible ([<A HREF=#13.1>1</A>]) and multi-resource ([<A HREF=#13.2>2</A>]) JSS generalize the allocation of a machine and additional resources for an operation to suit practical scheduling applications. In this work, we consider a <em> Multi-resource Partial-ordering Flexible JSS </em> (MPF-JSS) problem, where multiple resources are needed for executing operations, and jobs consist of partially-ordered sequences of operations to be completed. More specifically, we distinguish machines and engineers as two separate sets of resources required to perform an operation. Flexibility lies in the choice among several resources with the required skills in each category. The goal is to determine the best possible execution order and allocation of operations to resources for minimizing the total tardiness of jobs wrt. their deadlines. We model the MPF-JSS problem by an encoding in Answer Set Programming (ASP) with Difference Logic (DL) ([<A HREF=#13.4>4</A>]) and take advantage of multi-shot solving ([<A HREF=#13.5>5</A>]). DL constraints allow for compactly expressing timing requirements, avoiding grounding issues that would otherwise be encountered when a feasible schedule necessitates a large number of time points. By means of multi-shot solving, we implement two strategies to identify upper time bounds on feasible schedules whose tardiness is further subject to minimization. We tested our proposed model on a dataset representing ten operational days of an Infineon Fault Analysis lab. Our experiments yield success to optimize schedules for 87 out of 91 real-world instances, while only a very small number of jobs can be handled without multi-shot solving.
</P>

<H3>2. Modeling MPF-JSS with Hybrid ASP</H3>
<P>
We consider a scheduling problem in which different resources are interrelated to process the upcoming operations. In particular, MPF-JSS is an extension of the classical JSS problem where three additional aspects are considered: (a) <em> Multi-resources </em> – several categories of resources can be required to execute an operation; (b) <em>Partially-ordered </em> – some operations cannot be executed before completing their predecessors and others are unaffected by such constraints; and (c) <em> Flexible </em> – an operation can be performed by a variety of available resources. More specifically, an MPF-JSS instance consists of a set of jobs, characterized by a partially ordered set of operations to be performed, where each operation needs to be allocated to some machine and (possibly) an engineer with the required skills. The following constraints must be respected: (i) once an operation starts, it cannot be interrupted; (ii) each resource can perform only one operation at a time; (iii) the execution times of operations of the same job cannot overlap; and (iv) operations must be scheduled according to the partial order given by jobs. 
</P>
<P>
We propose two multi-shot ASP modulo DL solving strategies. The first approach incrementally increases the upper bound on the tardiness of each job in order to identify a limit for which schedules are feasible. That is, search starts with the tardiness bound 0, and if this yields unsatisfiability (UNSAT), the bound is incremented by a constant, set by a parameter of our Python control script on top of <em>clingo</em>[DL] ([<A HREF=#13.6>6</A>]), and this process proceeds until some schedule is found. Figure 1 illustrates an execution of the incremental search strategy, where the bound on jobs’ tardiness is increased in steps of size 2 until satisfiability (SAT) is obtained with the time bound 8. ASP optimization methods are then used to find a schedule minimizing the total tardiness, i.e., the sum of delays over jobs completed after their deadlines.
</P>
<P>
The second approach performs an exponential binary search for the exact tardiness bound at which schedules get feasible. As displayed in Figure 2, the increment on the bound is gradually increased up to step size 4 for finding the first schedule with the time bound 8. A binary search scheme then successively halves the step size for converging to the exact bound, 7 in this case, for which schedules are feasible, whose total tardiness is subject to ASP optimization in the last phase of the multi-shot solving process.
</P>

<H3>3. Results</H3>
<P>
We conducted experiments on a set of real-world instances of the MPF-JSS problem representing the operations at ten days randomly selected from the work records of an Infineon Fault Analysis lab. The instances yield the following approximate number of components based on the dimensions of the studied lab: <em>(i)</em> 50 operation kinds; <em>(ii)</em> 75 machines; and <em>(iii)</em> 45 engineers. For each of the selected days, the number of jobs ranges between 30 and 50. We further split each instance into up to ten sub-instances by picking 5, 10, 15, 20, etc. of the respective jobs, which resulted in a total of 91 instances of varying size. 
</P>

<P>
  For each obtained instance, we ran three solving strategies with <em>clingo</em>[DL] (version 1.1.0): <em>(1) single-shot</em> – standard ASP modulo DL program with a tardiness bound precomputed using a heuristic; <em>(2) inc</em> – the incremental multi-shot variant with a constant step size of 20 time points; and <em>(3) exp</em> – the exponential multi-shot solving approach. We restricted each solver run to 2 hours wall clock time on an Intel 3930K workstation with 64GB RAM under Ubuntu 18.05.
</P>

<P>
  Figure 3 shows a cactus plot comparing the solving performance of the two multi-shot approaches and the single-shot version as baseline. The latter times out on all instances with more than 15 jobs and merely succeeds to optimize schedules on instances with 15 jobs for two of the ten days. The two multi-shot approaches significantly outperform the single-shot version. While the incremental strategy yields optimized schedules for 85 out of 91 instances, the exponential multi-shot variant scales up to 87 instances. This advantage is due to tighter tardiness bounds identified by the exponential strategy, thus reducing the efforts for ASP optimization to minimize the total tardiness. Given that a lower tardiness bound is more restrictive, the incremental variant manages to find better schedules than the exponential strategy for three instances, where the total tardiness improvement amounts to 80 time points on average.
</P>

<center>
<table class="tg"><thead><tr>
  <th class="tg-0lax"><center> <img src="figures/incremental.png" alt="Snow" style="width:100%" title="Figure 1: Incremental approach"> </center></th>
  <th class="tg-7zrl" rowspan="3"><center> <img src="figures/comparison.png" alt="Forest" style="width:100%" title="Figure 3: Cactus plot of solving times"> </center></th></tr>

  <tr><th class="tg-0lax"><center> <i>Figure 1: Incremental approach</i> </center> </th></tr><tr><th class="tg-0lax"><center><img src="figures/exponential.png" alt="Forest" style="width:100%" title="Figure 2: Exponential approach"></center></th></tr></thead>

  <tbody><tr><td class="tg-0lax"> <center><i>Figure 2: Exponential approach</i></center> </td><td class="tg-0lax"><center> <i> Figure 3: Cactus plot of solving times</i> </center> </td></tr></tbody>
</table>
</center>

<!-- Here comes a section header. -->

<H3>References</H3>

<!-- These references are automatically generated by EPTCS, from the latex source code of the
     contribution, using the EPTCS bibliography style. They are imported here manually.
     The tags <A NAME="13.1"></A> have been inserted manually; they catch hyperlinks.
     Make sure all "NAME"s throughout the proceedings are unique, for
     instance by employing the paper number (13) within the name.-->

<OL>
<LI><A NAME="13.1"></A>
  Peter Brucker & Rainer Schliel  (1990):
  <I>Job-shop scheduling with multi-purpose machines</I>.
  Computing 45(4),
  pp. 369&#8211;375,
  doi:<A HREF='https://doi.org/10.1007/BF02238804'
  target='_top'>10.1007/BF02238804</A>.

<LI><A NAME="13.2"></A>
  St´ephane Dauz`ere-P´er`es, W. Roux & Jean Lasserre (1998):
  <I>Multi-resource shop scheduling with resource flexibility.</I>.
  EJOR 107(2),
  pp. 289&#8211;305,
  doi:<A HREF='https://doi.org/10.1016/S0377-2217(97)00341-X'
  target='_top'>10.1016/S0377-2217(97)00341-X</A>.

<LI><A NAME="13.3"></A>
  Giulia Francescutto, Konstantin Schekotihin & Mohammed El-Kholany (2021):
  <I>Solving a multi-resource partial-ordering flexible variant of the job-shop scheduling problem with hybrid ASP</I>.
  In: Proceedings of the European Conference on Logics in Artificial Intelligence (JELIA 2021), 
  Springer, 
  pp. 313&#8211;328.
  doi:<A HREF=' https://doi.org/10.1007/978-3-030-75775-5_21'
  target='_top'>10.1007/978-3-030-75775-5_21</A>

<LI><A NAME="13.4"></A>
  Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Max Ostrowski, Torsten Schaub & Philipp Wanko (2016):
  <I>Theory solving made easy with clingo 5</I>.
  In: Technical Communications of the International Conference on Logic Programming (ICLP 2016),
  Leibniz International Proceedings in Informatics,
  pp. 2:1&#8211;2:15.
  doi:<A HREF='https://drops.dagstuhl.de/opus/volltexte/2016/6733/'
  target='_top'>10.4230/OASIcs.ICLP.2016.2</A>.

<LI><A NAME="13.5"></A>
  Martin Gebser, Roland Kaminski, Benjamin Kaufmann & Torsten Schaub (2019):
  <I>Multi-shot ASP solving with clingo</I>.
  TPLP 19(1),
  pp. 27&#8211;82,
  doi:<A HREF='https://doi.org/10.1017/S1471068418000054'
  target='_top'>10.1017/S1471068418000054</A>.

<LI><A NAME="13.6"></A>
  Tomi Janhunen, Roland Kaminski, Max Ostrowski, Sebastian Schellhorn, Philipp Wanko & Torsten Schaub (2017):
  <I>Clingo goes linear constraints over reals and integers</I>.
  TPLP 17(5-6),
  pp. 872 &#8211; 888,
  doi:<A HREF='https://doi.org/10.1017/S1471068417000242'
  target='_top'>10.1017/S1471068417000242</A>.

<LI><A NAME="13.7"></A>
  Selmer Martin Johnson (1954):
  <I>Optimal two-and three-stage production schedules with setup times included</I>.
  Naval Research Logistics Quarterly 1(1),
  pp. 61&#8211;68,
  doi:<A HREF='https://doi.org/10.1002/nav.3800010110'
  target='_top'>10.1002/nav.3800010110</A>


</OL>
